<!DOCTYPE html>
<html lang="en"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Pattern: Parallel Agent Coordination | AI Best Practices Knowledge Base</title>
  <meta name="description" content="Use git-based decentralized coordination to enable parallel agent work without conflict.">
  <meta name="color-scheme" content="light dark">

  
  <meta property="og:title" content="Pattern: Parallel Agent Coordination">
  <meta property="og:description" content="Use git-based decentralized coordination to enable parallel agent work without conflict.">
  <meta property="og:type" content="article">

  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

  
  <link rel="stylesheet" href="../css/style.css">

  
  <link rel="icon" href="../favicon.svg" type="image/svg+xml">
</head>
<body class="section-patterns"><header class="site-header">
  <nav class="nav-container">
    <a class="nav-logo" href="../index.html">
      <svg class="nav-logo-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
        <circle cx="12" cy="8" r="2" fill="currentColor"/>
        <circle cx="7" cy="15" r="2" fill="currentColor"/>
        <circle cx="17" cy="15" r="2" fill="currentColor"/>
        <line x1="12" y1="10" x2="7" y2="13" stroke="currentColor" stroke-width="1.5"/>
        <line x1="12" y1="10" x2="17" y2="13" stroke="currentColor" stroke-width="1.5"/>
        <line x1="7" y1="15" x2="17" y2="15" stroke="currentColor" stroke-width="1.5"/>
      </svg>
      <span>AI Best Practices</span>
    </a>
    <div class="nav-links">
      <a class="nav-link" data-section="guides" href="../guides/index.html">Guides</a>
      <a class="nav-link" data-section="patterns" href="../patterns/index.html">Patterns</a>
      <a class="nav-link" data-section="deep-dives" href="../deep-dives/index.html">Deep Dives</a>
      <a class="nav-link" data-section="references" href="../references/index.html">References</a>
      <a class="nav-link" data-section="tags" href="../tags/index.html">Tags</a>
    </div>
    <div class="nav-actions">
      <button class="dark-mode-toggle" aria-label="Toggle dark mode" type="button">
        <svg class="icon-sun" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
        </svg>
        <svg class="icon-moon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
        </svg>
      </button>
      <button class="nav-toggle" aria-label="Toggle menu" type="button">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
  </nav>
</header>
<main>
<div class="page-container">
  
<nav class="breadcrumbs" aria-label="Breadcrumb">
  <ol>
    <li><a href="../index.html">Home</a></li>
    
      
    
      
        <li><a href="../patterns/index.html">Patterns</a></li>
      
    
    <li aria-current="page">Pattern: Parallel Agent Coordination</li>
  </ol>
</nav>



  <div class="article-layout has-toc">
    <article class="article">
      <header class="article-header">
        <h1 class="article-title">Pattern: Parallel Agent Coordination</h1>
        <div class="meta-bar">
  
  <time class="meta-date" datetime="2026-02-05">
    February 5, 2026
  </time>
  

  

  <span class="meta-reading-time">6 min read</span>

  <div class="meta-links">
    
    
    
  </div>

  
  
</div>

        
<div class="tag-pills">
  
  
  
  <a href="../tags/pattern.html" class="tag-pill">pattern</a>
  
  
  
  
  <a href="../tags/parallel-agents.html" class="tag-pill">parallel-agents</a>
  
  
  
  
  <a href="../tags/coordination.html" class="tag-pill">coordination</a>
  
  
  
  
  <a href="../tags/git-sync.html" class="tag-pill">git-sync</a>
  
  
  
  
  <a href="../tags/task-locking.html" class="tag-pill">task-locking</a>
  
  
</div>


      </header>

      <div class="article-content">
        <h2 id="problem">Problem</h2>
<p>A single agent is too slow for large projects. Building a 100,000-line codebase one session at a time could take months. The obvious solution &mdash; running multiple agents in parallel &mdash; introduces new failure modes: agents overwrite each other&rsquo;s work, duplicate effort on the same problem, create merge conflicts, and produce inconsistent code because they have no shared context.</p>
<p>Naively adding agents does not scale. Without coordination infrastructure, more agents can mean less progress.</p>
<h2 id="solution">Solution</h2>
<p>Use <strong>git-based decentralized coordination with task locking</strong> to enable parallel agent work. Each agent operates independently with its own context, and git serves as the shared state layer. No agent communicates with any other agent directly. All coordination happens through the repository.</p>
<h2 id="mechanism">Mechanism</h2>
<h3 id="isolated-execution-environments">Isolated Execution Environments</h3>
<p>Each agent runs in its own isolated Docker container. All containers share the same upstream git repository. Isolation prevents agents from interfering with each other&rsquo;s file systems, processes, or intermediate state. The only shared surface is git.</p>
<h3 id="task-claiming-via-lock-files">Task Claiming via Lock Files</h3>
<p>Agents claim work by writing lock files to a <code>current_tasks/</code> directory in the repository. Before starting on a task (e.g., fixing a specific failing test), the agent writes a lock file indicating it has claimed that task. Other agents check this directory before selecting work and skip already-claimed tasks.</p>
<p>This is optimistic concurrency control: agents assume they can claim a task, and git&rsquo;s merge mechanics resolve conflicts if two agents claim the same task simultaneously.</p>
<h3 id="git-synchronization">Git Synchronization</h3>
<p>The merge workflow prevents duplicate work and maintains repository coherence:</p>
<ol>
<li><strong>Pull</strong> the latest changes from upstream.</li>
<li><strong>Merge</strong> upstream changes into the local branch.</li>
<li><strong>Push</strong> the agent&rsquo;s completed work.</li>
<li><strong>Release</strong> the lock file for the completed task.</li>
</ol>
<p>Each agent follows this cycle on every iteration. Frequent synchronization keeps agents&rsquo; local views of the codebase reasonably current and reduces the window for conflicting changes.</p>
<h3 id="fresh-sessions-with-git-based-memory">Fresh Sessions with Git-Based Memory</h3>
<p>Each loop iteration starts a <strong>fresh session</strong> with no conversation memory. The agent does not remember what it did in the previous iteration. Instead, context comes entirely from:</p>
<ul>
<li>The current state of the repository (code, tests, build output)</li>
<li>README and progress files maintained in the repository</li>
<li>Lock files indicating what other agents are working on</li>
<li>Git history showing recent changes</li>
</ul>
<p>This is the infinite loop pattern:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#66d9ef">while</span> true; <span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>  claude -p <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>cat AGENT_PROMPT.md<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>The agent prompt references the repository state, not any prior conversation. This design eliminates context window limits as a constraint on project duration &mdash; the project can run for weeks because no single session needs to hold the full history.</p>
<h3 id="cicd-enforcement">CI/CD Enforcement</h3>
<p>New commits cannot break existing passing tests. This hard constraint prevents the common failure mode where one agent&rsquo;s fix breaks another agent&rsquo;s previously-working code. The CI gate is non-negotiable: if your change breaks something, it does not merge.</p>
<h2 id="when-parallelism-helps">When Parallelism Helps</h2>
<p>Parallelism provides near-linear speedup when the work decomposes into <strong>many independent subtasks</strong>:</p>
<ul>
<li><strong>Many failing test cases.</strong> Each agent picks a different failing test. The tasks are naturally independent &mdash; fixing one test rarely affects another.</li>
<li><strong>Orthogonal features.</strong> Different agents work on different, non-overlapping features or modules.</li>
<li><strong>Specialist roles.</strong> Agents with different responsibilities (core development, deduplication, performance optimization, code quality review, documentation) work on orthogonal concerns that rarely produce conflicting changes.</li>
</ul>
<p>The ideal case: N independent tasks, N agents, near-Nx throughput.</p>
<h2 id="when-parallelism-fails">When Parallelism Fails</h2>
<p>Parallelism provides <strong>zero advantage</strong> on monolithic tasks:</p>
<ul>
<li><strong>Single bottleneck bugs.</strong> When compiling a large program fails due to one root cause, all agents independently discover the same bug, produce the same fix, and overwrite each other. N agents produce 1x throughput at Nx cost.</li>
<li><strong>Highly coupled code.</strong> When every change touches the same files, merge conflicts dominate. Agents spend more time resolving conflicts than making progress.</li>
<li><strong>Sequential dependencies.</strong> When task B requires the output of task A, only one agent can make progress at a time regardless of how many are available.</li>
</ul>
<p>The failure case: 1 monolithic task, N agents, 1x throughput, Nx cost.</p>
<h2 id="workaround-for-monolithic-tasks-oracle-based-testing">Workaround for Monolithic Tasks: Oracle-Based Testing</h2>
<p>When a task appears monolithic (e.g., &ldquo;the compiled program crashes&rdquo;), use a <strong>known-good implementation as an oracle</strong> to manufacture task boundaries:</p>
<ol>
<li>Compile the target program with a known-good tool (e.g., GCC) to produce a reference binary.</li>
<li>Randomly split compilation units between the project compiler and the oracle.</li>
<li>Binary-search to identify which specific compilation unit causes the failure.</li>
<li>The failing unit becomes a scoped, independent task suitable for a single agent.</li>
</ol>
<p>This technique converts one opaque failure into many small, independent, verifiable tasks &mdash; exactly the structure parallel agents need. It is generalizable to any domain where a reference implementation exists.</p>
<h2 id="role-specialization">Role Specialization</h2>
<p>Rather than running N identical generalist agents, deploy <strong>specialists</strong> with orthogonal responsibilities:</p>
<ul>
<li><strong>Core developers</strong> (multiple): Fix failing tests, implement new features, extend functionality.</li>
<li><strong>Deduplicator</strong> (one): Scans the codebase for duplicate or near-duplicate code and consolidates it.</li>
<li><strong>Performance optimizer</strong> (one): Profiles compilation speed and targets bottlenecks.</li>
<li><strong>Code quality critic</strong> (one): Reviews code for correctness patterns, style consistency, and potential bugs.</li>
<li><strong>Documentation maintainer</strong> (one): Keeps README files, progress logs, and inline documentation current.</li>
</ul>
<p>Specialists work on different dimensions of the same codebase. Their changes are orthogonal by design &mdash; the optimizer&rsquo;s changes rarely conflict with the deduplicator&rsquo;s changes. This reduces merge conflicts and duplicate work without explicit coordination.</p>
<h2 id="anti-patterns">Anti-Patterns</h2>
<h3 id="n-agents-on-a-single-threaded-problem">N Agents on a Single-Threaded Problem</h3>
<p>Running multiple agents on a task that has no natural decomposition. All agents converge on the same bottleneck, produce identical or conflicting fixes, and waste compute. Before adding agents, verify that independent subtasks exist.</p>
<h3 id="sharing-conversation-context-between-agents">Sharing Conversation Context Between Agents</h3>
<p>Attempting to pass conversation history or shared memory between agents. This creates coupling, synchronization problems, and context window pressure. Use git as the shared state layer. Context comes from the repository, not from other agents&rsquo; conversations.</p>
<h3 id="no-task-locking">No Task Locking</h3>
<p>Running parallel agents without a mechanism to prevent duplicate work. Without lock files or equivalent claiming mechanisms, agents independently select the same &ldquo;most obvious&rdquo; task and produce redundant work. The overhead of a locking system is minimal compared to the waste of duplicate effort.</p>
<h3 id="full-test-suites-every-iteration">Full Test Suites Every Iteration</h3>
<p>Allowing agents to run the complete test suite on every iteration. Agents have no internal sense of time-cost tradeoff and will happily spend hours running tests instead of making progress. Provide a <code>--fast</code> option that runs a random 1-10% sample of tests. Agents use the fast option during development and run the full suite only before committing.</p>
<h2 id="scale-evidence">Scale Evidence</h2>
<p>The Carlini parallel compiler project provides the strongest empirical validation of this pattern:</p>
<ul>
<li><strong>16 parallel Claude instances</strong> coordinated via git</li>
<li><strong>Approximately 2,000 sessions</strong> over two weeks</li>
<li><strong>100,000 lines</strong> of working Rust compiler code produced</li>
<li><strong>Total cost: approximately $20,000</strong></li>
<li><strong>The compiler successfully compiled</strong> the Linux kernel, QEMU, FFmpeg, and Doom</li>
</ul>
<p>The coordination infrastructure &mdash; Docker isolation, git synchronization, task locking, oracle-based testing, CI/CD enforcement &mdash; was the critical enabler. The same model (Claude) was available to everyone. The parallel coordination harness is what converted 16 independent agents into a functioning development team.</p>
<p>See also: <a href="../deep-dives/parallel-compiler-lessons.html">What 100 Parallel Agents Taught Us</a> for the full case study, and <a href="../patterns/task-scoping.html">Task Scoping</a> for how scoping interacts with parallelism.</p>
<h2 id="sources">Sources</h2>
<ul>
<li><strong>Carlini, Nicholas.</strong> &ldquo;Building a C compiler with Claude as my coding agent.&rdquo; Anthropic Engineering Blog. <a href="https://www.anthropic.com/engineering/building-c-compiler">https://www.anthropic.com/engineering/building-c-compiler</a></li>
</ul>

      </div>

      
      <div class="article-sources">
        <h3>Sources</h3>
        <ul>
          <li><a href="https://www.anthropic.com/engineering/building-c-compiler">https://www.anthropic.com/engineering/building-c-compiler</a></li>
        </ul>
      </div>
      

      <nav class="article-nav">
        
        
        <a href="../patterns/harness-engineering.html" class="article-nav-link article-nav-link--next">
          <span class="article-nav-direction">Next</span>
          <span class="article-nav-title">Pattern: Harness Engineering</span>
        </a>
        
      </nav>
    </article>

    
<aside class="toc-sidebar" aria-label="Table of Contents">
  <div class="toc-container">
    <h2 class="toc-title">On this page</h2>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#solution">Solution</a></li>
    <li><a href="#mechanism">Mechanism</a>
      <ul>
        <li><a href="#isolated-execution-environments">Isolated Execution Environments</a></li>
        <li><a href="#task-claiming-via-lock-files">Task Claiming via Lock Files</a></li>
        <li><a href="#git-synchronization">Git Synchronization</a></li>
        <li><a href="#fresh-sessions-with-git-based-memory">Fresh Sessions with Git-Based Memory</a></li>
        <li><a href="#cicd-enforcement">CI/CD Enforcement</a></li>
      </ul>
    </li>
    <li><a href="#when-parallelism-helps">When Parallelism Helps</a></li>
    <li><a href="#when-parallelism-fails">When Parallelism Fails</a></li>
    <li><a href="#workaround-for-monolithic-tasks-oracle-based-testing">Workaround for Monolithic Tasks: Oracle-Based Testing</a></li>
    <li><a href="#role-specialization">Role Specialization</a></li>
    <li><a href="#anti-patterns">Anti-Patterns</a>
      <ul>
        <li><a href="#n-agents-on-a-single-threaded-problem">N Agents on a Single-Threaded Problem</a></li>
        <li><a href="#sharing-conversation-context-between-agents">Sharing Conversation Context Between Agents</a></li>
        <li><a href="#no-task-locking">No Task Locking</a></li>
        <li><a href="#full-test-suites-every-iteration">Full Test Suites Every Iteration</a></li>
      </ul>
    </li>
    <li><a href="#scale-evidence">Scale Evidence</a></li>
    <li><a href="#sources">Sources</a></li>
  </ul>
</nav>
  </div>
</aside>


  </div>
</div>

    </main><footer class="site-footer">
  <div class="footer-container">
    <div class="footer-brand">
      <span class="footer-logo">AI Best Practices</span>
      <p class="footer-description">What the best practitioners know about AI-assisted software development.</p>
    </div>
    <div class="footer-nav">
      <div class="footer-section">
        <h3>Content</h3>
        <ul>
          <li><a href="../guides/index.html">Guides</a></li>
          <li><a href="../deep-dives/index.html">Deep Dives</a></li>
          <li><a href="../tags/index.html">Topics</a></li>
        </ul>
      </div>
      <div class="footer-section">
        <h3>Resources</h3>
        <ul>
          <li><a href="../patterns/index.html">Patterns</a></li>
          <li><a href="../references/index.html">References</a></li>
          <li><a href="../synthesis/index.html">Synthesis</a></li>
        </ul>
      </div>
    </div>
    <div class="footer-bottom">
      <p>Built with Hugo. Content sourced from practitioner experience.</p>
    </div>
  </div>
</footer>
<script src="../js/main.js" defer></script>
  </body>
</html>
